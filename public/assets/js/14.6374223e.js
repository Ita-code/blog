(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{574:function(t,s,e){"use strict";e.r(s);var n=e(8),a=Object(n.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"代码执行在做什么时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码执行在做什么时"}},[t._v("#")]),t._v(" 代码执行在做什么时")]),t._v(" "),e("p",[t._v("JavaScript语言的执行环节是"),e("code",[t._v("单线程")]),t._v("single thread）")]),t._v(" "),e("p",[e("strong",[t._v("单线程")]),t._v("指的是一次只能完成一件任务。如果有多个任务，就必须排队，前面一个完成，在执行后面一个任务。故"),e("strong",[t._v("JS引擎不能同时做两件事，所以说异步不是在做两件事")])]),t._v(" "),e("p",[t._v("以"),e("code",[t._v("setTimeout")]),t._v("为例，setTimeout里面的代码一定会在当前环境中的任务执行完了【之后】才执行。")]),t._v(" "),e("p",[t._v("异步意味着不等待任务结束，并没有强制要求两个任务【同时进行】")]),t._v(" "),e("h3",{attrs:{id:"同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[t._v("#")]),t._v(" 同步")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("你可以理解为同一个时间，你只能干一件事。今天下班早，你想给女朋友打个电话，女朋友可能跟其他小伙伴一起吃饭呢，\n由于手机静音，所以听不到，你就一直打，一直打，啥都没干，把时间都浪费了，这就叫同步。因为js是单线程的嘛，所以js从小就是同步的。\n\n来一段代码：\nfunction second() {\n    console.log('second')\n}\nfunction first(){\n    console.log('first')\n    second()\n    console.log('Last')\n}\nfirst()\n\n这个很简单，执行打印结果：\nfirst、second、last\n")])])]),e("h3",{attrs:{id:"消息队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),e("p",[e("code",[t._v("同步代码")]),t._v("执行=》调用栈的概念【后进先出】")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("当执行此代码时，将创建一个全局执行上下文并将其推到调用堆栈的顶部；// 这个不太重要，下面是重点\nfirst()函数先上，现在他在顶部；\n然后打印‘first’，然后执行完了，这个时候这个console.log会自动弹走，就是这个console.log虽然是后进来的，但是他先走了；\n现在first函数仍然在顶部，他下面还有second函数，所以不会弹走；\n执行second()函数,这时候second函数在顶部；\n打印‘second’，然后执行完了，弹走这个console.log，这时候second在顶部；\n这个时候second函数的事儿都干完了，他也弹走了，这时候first函数在顶部；\n浏览器会问，first你还有事吗，first说我还有一个，执行打印‘last’\n")])])]),e("h3",{attrs:{id:"异步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("来段代码：\nconst getList = () => {\n    setTimeout(() => {\n        console.log('我执行了！');\n    }, 2000);\n};\nconsole.log('Hello World');\ngetList();\nconsole.log('哈哈哈');\n\n执行顺序是：\nHello World、哈哈哈、我执行了！（两秒以后执行最后一个）\n")])])]),e("h3",{attrs:{id:"消息队列-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息队列-2"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),e("p",[t._v("同步的时候，浏览器会维护一个‘执行栈’，除了执行栈，在开启多线程的时候，浏览器还会维护一个消息列表，除了主线程，其余的都是副线程，这些副线程合起来就叫消息列表。 我们用消息列表的概念分析一下上面的代码：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("按照执行顺序console.log('Hello World')先执行，浏览器一看，中央军（主线程）！你先过；\n然后是getlist函数执行，浏览器看到setTimeout,你是八L（副线程）！你先靠边等着；\n然后是console.log('哈哈哈')执行，中央军（主线程）！你也过；\n然后浏览器问，还有中央军吗？没了，八L开始过！\n")])])]),e("h3",{attrs:{id:"疑点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#疑点"}},[t._v("#")]),t._v(" 疑点")]),t._v(" "),e("p",[t._v("为什么promise.then比定时器先执行呢？")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("setTimeout(function() {\n    console.log('我是定时器！');\n})\nnew Promise(function(resolve) {\n    console.log('我是promise！');//在主线上执行\n    resolve();\n}).then(function() {\n    console.log('我是then！');//微任务副线程\n})\nconsole.log('我是主线程！');\n\n执行顺序：\n我是promise！\n我是主线程！\n我是then！\n我是定时器！\n")])])]),e("h3",{attrs:{id:"事件轮询"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件轮询"}},[t._v("#")]),t._v(" 事件轮询")]),t._v(" "),e("p",[t._v("浏览器为了提升效率，为js开启了一个不太一样的多线程，因为js不能同时执行嘛，那副线程（注意是副线程里面哈）里面谁执行，这个选择的过程，就可以理解为事件轮询。我们先用事件轮询的顺序分析一下上面的代码，再来上概念")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("promise函数肯定首先执行，他是主线程嘛，打印‘我是promise’；\n然后继续走主线程，打印‘我是主线程’；\n然后主线程走完了，开始走消息列表；\n（宏任务和微任务一会再讲）\n这个时候会先执行promise.then，因为他是微任务，里面的‘我是then！’\n消息列表里面在上面的是定时器，但是定时器是宏任务，优先级比较低，所以会往后排；\n")])])]),e("h3",{attrs:{id:"宏任务、微任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务"}},[t._v("#")]),t._v(" 宏任务、微任务")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("**宏任务（Macrotasks）：**js同步执行的代码块，setTimeout、setInterval、XMLHttprequest、setImmediate、I/O、UI rendering等。\n\n**微任务（Microtasks）：**promise、process.nextTick（node环境）、Object.observe, MutationObserver等。\n\n微任务比宏任务要牛逼一点\n\n浏览器执行的顺序：\n(1)执行主代码块，这个主代码块也是宏任务\n(2)若遇到Promise，把then之后的内容放进微任务队列\n(3)遇到setTimeout，把他放到宏任务里面\n(4)一次宏任务执行完成，检查微任务队列有无任务 \n(5)有的话执行所有微任务 \n(6)执行完毕后，开始下一次宏任务。\n")])])])])}),[],!1,null,null,null);s.default=a.exports}}]);